<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Javascript-宏队列与微队列 · 猿话实验室</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="背景"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Javascript-宏队列与微队列 · 猿话实验室"/><meta property="og:type" content="website"/><meta property="og:url" content=" https://ange6.github.io/docs/blog/2018/7/04/js"/><meta property="og:description" content="背景"/><meta property="og:image" content=" https://ange6.github.io/docs/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content=" https://ange6.github.io/docs/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/docs/img/favicon.ico"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href=" https://ange6.github.io/docs/blog/atom.xml" title="猿话实验室 Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href=" https://ange6.github.io/docs/blog/feed.xml" title="猿话实验室 Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/docs/js/scrollSpy.js"></script><link rel="stylesheet" href="/docs/css/main.css"/><script src="/docs/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/docs/en"><img class="logo" src="/docs/img/favicon.ico" alt="猿话实验室"/><h2 class="headerTitleWithLogo">猿话实验室</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/docs/en/cli" target="_self">CLI</a></li><li class=""><a href="/docs/docs/en/js-sdk" target="_self">JS-SDK</a></li><li class=""><a href="/docs/docs/en/template" target="_self">模板</a></li><li class=""><a href="/docs/en/help" target="_self">关于</a></li><li class="siteNavGroupActive"><a href="/docs/blog/" target="_self">博客</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Recent Posts</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Recent Posts</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/blog/2020/6/12">Symbol-ES6神奇的数据类型</a></li><li class="navListItem"><a class="navItem" href="/docs/blog/2020/6/9">关于var、let、const，知多少？</a></li><li class="navListItem"><a class="navItem" href="/docs/blog/2020/4/23/cli">0基础教你开发自己的CLI（一）</a></li><li class="navListItem"><a class="navItem" href="/docs/blog/2019/8/4/wx-miniapp">教你快速获取小程序任意页面路径</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/blog/2018/7/04/js">Javascript-宏队列与微队列</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer postContainer blogContainer"><div class="wrapper"><div class="lonePost"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/docs/blog/2018/7/04/js">Javascript-宏队列与微队列</a></h1><p class="post-meta">July 4, 2018</p><div class="authorBlock"><p class="post-authorName"><a href="https://mp.weixin.qq.com/s/NMhc5dYVk7zv9ZTZd9LopQ" target="_blank" rel="noreferrer noopener">猿话</a></p></div></header><div><span><p>背景</p>
<p>当我们忙于公司业务开发，习惯于control+c、control+v这种机械化操作时，我们将会离我们的理想越来越远。你可能会忘记或者疏于最基本，最底层的原理。在此，我们将一起踏上回头路，去探望我们遗失的美好。</p>
<p>之前在网上看了很多关于setTimeout,setinterval,promise等的文章，都能起到延迟执行的效果。但具体怎么执行，顺序怎样，讲解的都很片面，最近正好也被人问道，所以总结了一下以供大家参考。写的不好请留言多多指教，谢谢。</p>
<p>说起setTimeout,setinterval,promise等能够实现异步执行，我们必须先了解下JS的</p>
<p>事件循环</p>
<p>Event Loop，不管是前端、还是移动端（IOS和Android）等开发，都离不开事件循环机制，他会循环监听任务，并在适当的时机取出、执行和释放任务，更新UI等操作，更新UI渲染界面比较耗时，不同的渲染引擎有自己的一套渲染时机逻辑，决定要不要马上执行更新，毕竟更新UI成本大。</p>
<!--truncate-->
<p>背景</p>
<p>当我们忙于公司业务开发，习惯于control+c、control+v这种机械化操作时，我们将会离我们的理想越来越远。你可能会忘记或者疏于最基本，最底层的原理。在此，我们将一起踏上回头路，去探望我们遗失的美好。</p>
<p>之前在网上看了很多关于setTimeout,setinterval,promise等的文章，都能起到延迟执行的效果。但具体怎么执行，顺序怎样，讲解的都很片面，最近正好也被人问道，所以总结了一下以供大家参考。写的不好请留言多多指教，谢谢。</p>
<p>说起setTimeout,setinterval,promise等能够实现异步执行，我们必须先了解下JS的</p>
<p>事件循环</p>
<p>Event Loop，不管是前端、还是移动端（IOS和Android）等开发，都离不开事件循环机制，他会循环监听任务，并在适当的时机取出、执行和释放任务，更新UI等操作，更新UI渲染界面比较耗时，不同的渲染引擎有自己的一套渲染时机逻辑，决定要不要马上执行更新，毕竟更新UI成本大。</p>
<p>任务队列</p>
<p>宏任务：script（全局任务）, setTimeout, setInterval, setImmediate, I/O, UI rendering.</p>
<p>微任务：process.nextTick, Promise.then, Object.observer, MutationObserver.</p>
<p>闭包</p>
<p>说起闭包，最明显的特点有三个，
1、函数套函数。
2、内部函数可以访问外部函数的变量。
3、局部变量，垃圾回收机制无法收回。</p>
<p>通过示例来查看执行顺序</p>
<pre><code class="hljs css language-js">
 <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'1 ===&gt; 全局队列 script'</span>)

setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'2 ===&gt; timeout1 '</span>)
<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'3 ===&gt; timeout1_promise'</span>)
    resolve()
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'4 ===&gt; timeout1_then'</span>)
})

},<span class="hljs-number">2000</span>)

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>;i &lt;= <span class="hljs-number">5</span>;i ++) {
setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
 <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'5 ===&gt; timeout2='</span> + i)
},i*<span class="hljs-number">1000</span>)
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'6 ===&gt; 全局队列 script ='</span> + i)
}

<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>{
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'7 ===&gt; promise1'</span>)
resolve()
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'8 ===&gt; then1'</span>)
})

setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'9 ===&gt; timeout3'</span>)
<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>{
 <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'10 ===&gt; timeout3_promise'</span>)
 resolve()
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
 <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'11 ===&gt; timeout3_promise_then'</span>)
})
}, <span class="hljs-number">1000</span>)

<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>{
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'12 ===&gt; promise2'</span>)
resolve()
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'13 ===&gt; promise2_then2'</span>)
})

<span class="hljs-keyword">var</span> interval = setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'15 ===&gt; setinterval '</span>)
<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'16 ===&gt; setinterval_promise'</span>)
    resolve()
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'17 ===&gt; setinterval_then'</span>)
})
},<span class="hljs-number">1000</span>)

setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
clearInterval(interval)
}, <span class="hljs-number">1000</span>)

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'14 ===&gt; 全局队列 script'</span>)
</code></pre>
<p>输出结果</p>
<pre><code class="hljs">1 ===&gt; 全局队列<span class="hljs-built_in"> script
</span>VM1633:18 6 ===&gt; 全局队列<span class="hljs-built_in"> script </span>=1
VM1633:18 6 ===&gt; 全局队列<span class="hljs-built_in"> script </span>=2
VM1633:18 6 ===&gt; 全局队列<span class="hljs-built_in"> script </span>=3
VM1633:18 6 ===&gt; 全局队列<span class="hljs-built_in"> script </span>=4
VM1633:18 6 ===&gt; 全局队列<span class="hljs-built_in"> script </span>=5
VM1633:22 7 ===&gt; promise1
VM1633:39 12 ===&gt; promise2
VM1633:59 14 ===&gt; 全局队列<span class="hljs-built_in"> script
</span>VM1633:25 8 ===&gt; then1
VM1633:42 13 ===&gt; promise2_then2
undefined
VM1633:16 5 ===&gt; <span class="hljs-attribute">timeout2</span>=6
VM1633:29 9 ===&gt; timeout3
VM1633:31 10 ===&gt; timeout3_promise
VM1633:34 11 ===&gt; timeout3_promise_then
VM1633:46 15 ===&gt; setinterval 
VM1633:48 16 ===&gt; setinterval_promise
VM1633:51 17 ===&gt; setinterval_then
VM1633:4 2 ===&gt; timeout1 
VM1633:6 3 ===&gt; timeout1_promise
VM1633:9 4 ===&gt; timeout1_then
4VM1633:16 5 ===&gt; <span class="hljs-attribute">timeout2</span>=6
</code></pre>
<p>总结</p>
<pre><code class="hljs">1、js中为了防止线程阻塞，阻止全局代码的执行，衍生出很多异步执行解决方案，这些方案都会按需加载到指定的队列中，当全局队列执行完毕后，开始循环从 微队列-&gt;宏队列-&gt;微队列-&gt;宏队列...这种执行顺序执行下去。

2、当一个宏观队列执行完毕，立刻执行最近添加的微观队列。

3、这种逻辑也可以为首页加速带来思路。
</code></pre>
<p>在使用中有任何问题，欢迎留言反馈给我。书写不易，希望大家可以喜欢。</p>
</span></div></div><div class="blogSocialSection"></div></div><div class="blog-recent"><a class="button" href="/docs/blog/">Recent Posts</a></div></div></div><nav class="onPageNav"></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/docs/" class="nav-home"><img src="/docs/img/favicon.ico" alt="猿话实验室" width="66" height="58"/></a><div><h5>文档</h5><a href="/docs/docs/en/cli.html">CLI</a><a href="/docs/docs/en/js-sdk.html">JS SDK</a><a href="/docs/docs/en/template.html">模板库</a></div><div><h5>相关链接</h5><a href="https://react.docschina.org/" target="_blank" rel="noreferrer noopener">React</a><a href="https://cn.vuejs.org/" target="_blank">Vue</a></div><div><h5>其他</h5><a href="/docs/blog">Blog</a><a href="https://github.com/yuanhua118/" target="_blank">GitHub</a><a class="github-button" data-icon="octicon-star" data-count-href="/facebook/docusaurus/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><section class="copyright">Copyright © 2019-2020 猿话实验室</section></footer></div></body></html>